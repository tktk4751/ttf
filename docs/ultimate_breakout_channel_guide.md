# ğŸš€ Ultimate Breakout Channel (UBC) - å®Œå…¨æŠ€è¡“ã‚¬ã‚¤ãƒ‰

## æ¦‚è¦

**Ultimate Breakout Channel (UBC)** ã¯ã€äººé¡å²ä¸Šæœ€å¼·ã®ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ™ãƒ¼ã‚¹ãƒ–ãƒ¬ã‚¤ã‚¯ã‚¢ã‚¦ãƒˆãƒãƒ£ãƒãƒ«ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã§ã™ã€‚é©æ–°çš„ãª4å±¤çµ±åˆã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã‚Šã€è¶…ä½é…å»¶ãƒ»è¶…è¿½å¾“æ€§ãƒ»å½ã‚·ã‚°ãƒŠãƒ«å®Œå…¨é˜²å¾¡ã‚’å®Ÿç¾ã—ã€ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ•ã‚©ãƒ­ãƒ¼æˆ¦ç•¥ã«ãŠã„ã¦åœ§å€’çš„ãªæ€§èƒ½ã‚’ç™ºæ®ã—ã¾ã™ã€‚

## ğŸ¯ æ ¸å¿ƒæŠ€è¡“

### é©æ–°çš„4å±¤çµ±åˆã‚·ã‚¹ãƒ†ãƒ 

1. **è¶…é€²åŒ–ãƒ’ãƒ«ãƒ™ãƒ«ãƒˆå¤‰æ›** - ç¬æ™‚æŒ¯å¹…ãƒ»ä½ç›¸ãƒ»ãƒˆãƒ¬ãƒ³ãƒ‰å¼·åº¦ã‚’è¶…ä½é…å»¶ã§æ¤œå‡º
2. **é‡å­é©å¿œã‚«ãƒ«ãƒãƒ³ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼** - å‹•çš„ãƒã‚¤ã‚ºãƒ¢ãƒ‡ãƒªãƒ³ã‚° + é‡å­ã‚³ãƒ’ãƒ¼ãƒ¬ãƒ³ã‚¹èª¿æ•´
3. **ãƒã‚¤ãƒ‘ãƒ¼åŠ¹ç‡ç‡ï¼ˆHERï¼‰** - å¾“æ¥ERã‚’è¶…çµ¶é€²åŒ–ã•ã›ãŸãƒˆãƒ¬ãƒ³ãƒ‰å¼·åº¦æ¸¬å®šå™¨
4. **ã‚¦ã‚§ãƒ¼ãƒ–ãƒ¬ãƒƒãƒˆå¤šè§£åƒåº¦è§£æ** - è¤‡æ•°æ™‚é–“è»¸ã§ã®å¸‚å ´æ§‹é€ è§£æ

### é©å‘½çš„ç‰¹å¾´

- **å‹•çš„é©å¿œãƒãƒ³ãƒ‰å¹…**: ãƒˆãƒ¬ãƒ³ãƒ‰å¼·åº¦åæ¯”ä¾‹ - å¼·ã„æ™‚ã¯ç‹­ãã€å¼±ã„æ™‚ã¯åºƒã
- **è¶…ä½é…å»¶**: ãƒ’ãƒ«ãƒ™ãƒ«ãƒˆ + ã‚«ãƒ«ãƒãƒ³çµ±åˆã«ã‚ˆã‚‹äºˆæ¸¬çš„è£œæ­£
- **è¶…è¿½å¾“æ€§**: é‡å­ã‚³ãƒ’ãƒ¼ãƒ¬ãƒ³ã‚¹ + ã‚¦ã‚§ãƒ¼ãƒ–ãƒ¬ãƒƒãƒˆé©å¿œèª¿æ•´
- **å½ã‚·ã‚°ãƒŠãƒ«å®Œå…¨é˜²å¾¡**: å¤šå±¤ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚° + ä¿¡é ¼åº¦è©•ä¾¡
- **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å­¦ç¿’**: å¸‚å ´çŠ¶æ³ã«å¿œã˜ãŸå‹•çš„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¿æ•´

## ğŸ“Š æŠ€è¡“çš„è©³ç´°

### 1. è¶…é€²åŒ–ãƒ’ãƒ«ãƒ™ãƒ«ãƒˆå¤‰æ›

å¾“æ¥ã®ãƒ’ãƒ«ãƒ™ãƒ«ãƒˆå¤‰æ›ã‚’é‡å­åŠ›å­¦çš„ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã§é€²åŒ–ã•ã›ãŸé©æ–°çš„ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼š

```python
# 8ç‚¹è¶…é«˜ç²¾åº¦ãƒ’ãƒ«ãƒ™ãƒ«ãƒˆå¤‰æ›
real_part = (
    prices[i] * 0.25 + prices[i-2] * 0.21 + 
    prices[i-4] * 0.15 + prices[i-6] * 0.09
)

imag_part = (
    prices[i-1] * 0.23 + prices[i-3] * 0.20 + 
    prices[i-5] * 0.13 + prices[i-7] * 0.08
)
```

**ç‰¹å¾´:**
- ç¬æ™‚æŒ¯å¹…ãƒ»ä½ç›¸æ¤œå‡º
- é‡å­ã‚³ãƒ’ãƒ¼ãƒ¬ãƒ³ã‚¹è£œæ­£
- ä½ç›¸å‹¢ã„è§£æã«ã‚ˆã‚‹ãƒˆãƒ¬ãƒ³ãƒ‰å¼·åº¦ç®—å‡º
- è¶…ä½é…å»¶ï¼ˆ8ãƒã‚¤ãƒ³ãƒˆã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ï¼‰

### 2. é‡å­é©å¿œã‚«ãƒ«ãƒãƒ³ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼

é‡å­ã‚³ãƒ’ãƒ¼ãƒ¬ãƒ³ã‚¹ç†è«–ã«ã‚ˆã‚Šé€²åŒ–ã—ãŸé©å¿œå‹ãƒã‚¤ã‚ºãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ï¼š

```python
# é‡å­ã‚³ãƒ’ãƒ¼ãƒ¬ãƒ³ã‚¹è¨ˆç®—
amplitude_coherence = min(amplitude[i] / (np.nanmean(amplitude[max(0, i-10):i+1]) + 1e-10), 2.0) * 0.5
phase_coherence = Î£(exp(-phase_diff)) / 5.0
quantum_coherence[i] = (amplitude_coherence * 0.6 + phase_coherence * 0.4)

# é©å¿œçš„ãƒã‚¤ã‚ºèª¿æ•´
process_noise = 0.001 * (1.0 - coherence)  # ã‚³ãƒ’ãƒ¼ãƒ¬ãƒ³ã‚¹é«˜ â†’ ãƒã‚¤ã‚ºä½
observation_noise = 0.01 * (1.0 + coherence)  # ã‚³ãƒ’ãƒ¼ãƒ¬ãƒ³ã‚¹é«˜ â†’ è¦³æ¸¬ç²¾åº¦é«˜
```

**ç‰¹å¾´:**
- å‹•çš„ãƒã‚¤ã‚ºãƒ¢ãƒ‡ãƒªãƒ³ã‚°
- é‡å­çŠ¶æ…‹ã«åŸºã¥ãé©å¿œèª¿æ•´
- äºˆæ¸¬çš„è£œæ­£æ©Ÿèƒ½
- å¸‚å ´ãƒã‚¤ã‚ºã®å®Œå…¨é™¤å»

### 3. ãƒã‚¤ãƒ‘ãƒ¼åŠ¹ç‡ç‡ï¼ˆHERï¼‰

å¾“æ¥ã®åŠ¹ç‡ç‡ã‚’å¤šæ¬¡å…ƒãƒ»éç·šå½¢ãƒ»é©å¿œçš„ã«é€²åŒ–ã•ã›ãŸé©æ–°çš„æŒ‡æ¨™ï¼š

```python
# å¤šæ¬¡å…ƒãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£
total_volatility = (
    linear_volatility * 0.5 + 
    nonlinear_volatility * 0.3 + 
    adaptive_volatility * 0.2
)

# éç·šå½¢å¤‰æ›
sigmoid_transform = 1.0 / (1.0 + exp(-base_efficiency * 10))
tanh_transform = tanh(base_efficiency * 5)
her_values[i] = (sigmoid_transform * 0.6 + tanh_transform * 0.4)
```

**ç‰¹å¾´:**
- ç·šå½¢ãƒ»éç·šå½¢ãƒ»é©å¿œçš„ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£ã®çµ±åˆ
- ã‚·ã‚°ãƒ¢ã‚¤ãƒ‰ + åŒæ›²ç·šæ­£æ¥ã®éç·šå½¢å¤‰æ›
- é«˜ç²¾åº¦ãƒˆãƒ¬ãƒ³ãƒ‰åŠ¹ç‡æ€§æ¸¬å®š
- ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é©å¿œèª¿æ•´

### 4. ã‚¦ã‚§ãƒ¼ãƒ–ãƒ¬ãƒƒãƒˆå¤šè§£åƒåº¦è§£æ

é›¢æ•£ã‚¦ã‚§ãƒ¼ãƒ–ãƒ¬ãƒƒãƒˆå¤‰æ›ã«ã‚ˆã‚‹å¸‚å ´æ§‹é€ ã®å®Œå…¨åˆ†è§£ï¼š

```python
# ãƒãƒ¼ãƒ«ãƒ»ã‚¦ã‚§ãƒ¼ãƒ–ãƒ¬ãƒƒãƒˆå¤‰æ›
# ãƒ¬ãƒ™ãƒ«1åˆ†è§£ï¼ˆé«˜å‘¨æ³¢ãƒ»ä½å‘¨æ³¢ï¼‰
high_freq[j] = (segment[j*2] - segment[j*2+1]) / sqrt(2)
low_freq[j] = (segment[j*2] + segment[j*2+1]) / sqrt(2)

# ãƒ¬ãƒ™ãƒ«2åˆ†è§£ï¼ˆä½å‘¨æ³¢ã‚’ã•ã‚‰ã«åˆ†è§£ï¼‰
trend_coeffs[j] = (low_freq[j*2] + low_freq[j*2+1]) / sqrt(2)
cycle_coeffs[j] = (low_freq[j*2] - low_freq[j*2+1]) / sqrt(2)
```

**ç‰¹å¾´:**
- ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ»ã‚µã‚¤ã‚¯ãƒ«ãƒ»ãƒã‚¤ã‚ºæˆåˆ†ã®å®Œå…¨åˆ†é›¢
- è¤‡æ•°æ™‚é–“è»¸ã§ã®å¸‚å ´æ§‹é€ è§£æ
- ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å¸‚å ´ãƒ¬ã‚¸ãƒ¼ãƒ åˆ¤å®š
- é«˜é€Ÿãƒãƒ¼ãƒ«ãƒ»ã‚¦ã‚§ãƒ¼ãƒ–ãƒ¬ãƒƒãƒˆå®Ÿè£…

### 5. å‹•çš„ãƒãƒ£ãƒãƒ«å¹…è¨ˆç®—

ãƒˆãƒ¬ãƒ³ãƒ‰å¼·åº¦åæ¯”ä¾‹ã®é©æ–°çš„ãƒãƒ³ãƒ‰å¹…èª¿æ•´ï¼š

```python
# æ ¸å¿ƒã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼šãƒˆãƒ¬ãƒ³ãƒ‰å¼·åº¦åæ¯”ä¾‹èª¿æ•´
trend_factor = max(0.3, 1.0 - 0.7 * trend_strength[i])  # å¼·ã„ãƒˆãƒ¬ãƒ³ãƒ‰ â†’ ç‹­ã„ãƒãƒ³ãƒ‰
efficiency_factor = max(0.4, 1.0 - 0.6 * her_values[i])  # é«˜åŠ¹ç‡ â†’ ç‹­ã„ãƒãƒ³ãƒ‰

# çµ±åˆèª¿æ•´ãƒ•ã‚¡ã‚¯ã‚¿ãƒ¼
integrated_factor = (
    trend_factor * 0.4 + 
    efficiency_factor * 0.35 + 
    regime_factor * 0.25
)
```

**ç‰¹å¾´:**
- ãƒˆãƒ¬ãƒ³ãƒ‰å¼·åº¦åæ¯”ä¾‹èª¿æ•´ï¼ˆå¼·ã„æ™‚ã¯ç‹­ãã€å¼±ã„æ™‚ã¯åºƒãï¼‰
- ãƒã‚¤ãƒ‘ãƒ¼åŠ¹ç‡ç‡ã«ã‚ˆã‚‹å¾®èª¿æ•´
- å¸‚å ´ãƒ¬ã‚¸ãƒ¼ãƒ ã«ã‚ˆã‚‹è¿½åŠ èª¿æ•´
- æ¥µç«¯å€¤åˆ¶é™ã«ã‚ˆã‚‹å®‰å®šæ€§ç¢ºä¿

## ğŸ® åŸºæœ¬çš„ãªä½¿ç”¨æ–¹æ³•

### ã‚¤ãƒ³ãƒãƒ¼ãƒˆã¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–

```python
from indicators.ultimate_breakout_channel import UltimateBreakoutChannel

# åŸºæœ¬è¨­å®š
ubc = UltimateBreakoutChannel(
    atr_period=14,           # ATRè¨ˆç®—æœŸé–“
    base_multiplier=2.0,     # åŸºæœ¬ãƒãƒ£ãƒãƒ«å¹…å€ç‡
    her_window=14,           # ãƒã‚¤ãƒ‘ãƒ¼åŠ¹ç‡ç‡ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦
    min_signal_quality=0.3   # æœ€å°ã‚·ã‚°ãƒŠãƒ«å“è³ªã—ãã„å€¤
)
```

### ãƒ‡ãƒ¼ã‚¿ã®è¨ˆç®—

```python
# ä¾¡æ ¼ãƒ‡ãƒ¼ã‚¿ï¼ˆDataFrame: OHLCå¿…é ˆï¼‰
result = ubc.calculate(price_data)

# çµæœã®å–å¾—
upper_channel = result.upper_channel      # ä¸Šéƒ¨ãƒãƒ£ãƒãƒ«
lower_channel = result.lower_channel      # ä¸‹éƒ¨ãƒãƒ£ãƒãƒ«
centerline = result.centerline            # ã‚»ãƒ³ã‚¿ãƒ¼ãƒ©ã‚¤ãƒ³
breakout_signals = result.breakout_signals # ãƒ–ãƒ¬ã‚¤ã‚¯ã‚¢ã‚¦ãƒˆã‚·ã‚°ãƒŠãƒ«
signal_quality = result.signal_quality    # ã‚·ã‚°ãƒŠãƒ«å“è³ª
```

### ã‚·ã‚°ãƒŠãƒ«ã®è§£é‡ˆ

```python
# ãƒ–ãƒ¬ã‚¤ã‚¯ã‚¢ã‚¦ãƒˆã‚·ã‚°ãƒŠãƒ«
# 1  = ä¸Šæ–¹ãƒ–ãƒ¬ã‚¤ã‚¯ã‚¢ã‚¦ãƒˆï¼ˆè²·ã„ã‚·ã‚°ãƒŠãƒ«ï¼‰
# -1 = ä¸‹æ–¹ãƒ–ãƒ¬ã‚¤ã‚¯ã‚¢ã‚¦ãƒˆï¼ˆå£²ã‚Šã‚·ã‚°ãƒŠãƒ«ï¼‰
# 0  = ã‚·ã‚°ãƒŠãƒ«ãªã—

buy_signals = np.where(result.breakout_signals == 1)[0]
sell_signals = np.where(result.breakout_signals == -1)[0]
```

## âš™ï¸ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼è©³ç´°è¨­å®š

### æ ¸å¿ƒãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼

| ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ | ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ | èª¬æ˜ | æ¨å¥¨ç¯„å›² |
|-------------|------------|------|----------|
| `atr_period` | 14 | ATRè¨ˆç®—æœŸé–“ | 10-21 |
| `base_multiplier` | 2.0 | åŸºæœ¬ãƒãƒ£ãƒãƒ«å¹…å€ç‡ | 1.5-3.0 |
| `her_window` | 14 | ãƒã‚¤ãƒ‘ãƒ¼åŠ¹ç‡ç‡ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ | 10-21 |
| `min_signal_quality` | 0.3 | æœ€å°ã‚·ã‚°ãƒŠãƒ«å“è³ªã—ãã„å€¤ | 0.2-0.7 |

### é«˜åº¦ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼

| ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ | ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ | èª¬æ˜ | ç”¨é€” |
|-------------|------------|------|------|
| `hilbert_window` | 8 | ãƒ’ãƒ«ãƒ™ãƒ«ãƒˆå¤‰æ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ | è¶…ä½é…å»¶èª¿æ•´ |
| `wavelet_window` | 16 | ã‚¦ã‚§ãƒ¼ãƒ–ãƒ¬ãƒƒãƒˆè§£æã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ | å¤šè§£åƒåº¦åˆ†æç²¾åº¦ |
| `src_type` | 'hlc3' | ä¾¡æ ¼ã‚½ãƒ¼ã‚¹ã‚¿ã‚¤ãƒ— | è¨ˆç®—åŸºæº–ä¾¡æ ¼ |

## ğŸ¯ æœ€é©åŒ–è¨­å®šã‚¬ã‚¤ãƒ‰

### ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ•ã‚©ãƒ­ãƒ¼æœ€é©åŒ–

```python
# å¼·ã„ãƒˆãƒ¬ãƒ³ãƒ‰ç›¸å ´ç”¨ï¼ˆè¿½å¾“æ€§é‡è¦–ï¼‰
ubc_trend = UltimateBreakoutChannel(
    atr_period=21,
    base_multiplier=1.5,     # ãƒãƒ³ãƒ‰å¹…ã‚’ç‹­ã‚ã¦è¿½å¾“æ€§å‘ä¸Š
    her_window=21,
    min_signal_quality=0.4   # å“è³ªã‚’ã‚„ã‚„é«˜ã‚ã«è¨­å®š
)

# å¼±ã„ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ»ãƒ¬ãƒ³ã‚¸ç›¸å ´ç”¨ï¼ˆå½ã‚·ã‚°ãƒŠãƒ«å›é¿ï¼‰
ubc_range = UltimateBreakoutChannel(
    atr_period=14,
    base_multiplier=2.5,     # ãƒãƒ³ãƒ‰å¹…ã‚’åºƒã’ã¦å½ã‚·ã‚°ãƒŠãƒ«å›é¿
    her_window=14,
    min_signal_quality=0.6   # é«˜å“è³ªã‚·ã‚°ãƒŠãƒ«ã®ã¿æ¡ç”¨
)
```

### æ™‚é–“è»¸åˆ¥æœ€é©åŒ–

```python
# çŸ­æœŸå–å¼•ç”¨ï¼ˆ1åˆ†-15åˆ†è¶³ï¼‰
ubc_short = UltimateBreakoutChannel(
    atr_period=10,
    base_multiplier=1.8,
    her_window=10,
    min_signal_quality=0.5
)

# ä¸­æœŸå–å¼•ç”¨ï¼ˆ1æ™‚é–“-4æ™‚é–“è¶³ï¼‰
ubc_medium = UltimateBreakoutChannel(
    atr_period=14,
    base_multiplier=2.0,
    her_window=14,
    min_signal_quality=0.4
)

# é•·æœŸå–å¼•ç”¨ï¼ˆæ—¥è¶³ä»¥ä¸Šï¼‰
ubc_long = UltimateBreakoutChannel(
    atr_period=21,
    base_multiplier=2.2,
    her_window=21,
    min_signal_quality=0.3
)
```

## ğŸ“ˆ é«˜åº¦ãªä½¿ç”¨æ–¹æ³•

### ãƒˆãƒ¬ãƒ³ãƒ‰è§£æ

```python
# ãƒˆãƒ¬ãƒ³ãƒ‰è§£æãƒ‡ãƒ¼ã‚¿ã®å–å¾—
trend_analysis = ubc.get_trend_analysis()

trend_strength = trend_analysis['trend_strength']      # ãƒˆãƒ¬ãƒ³ãƒ‰å¼·åº¦
hyper_efficiency = trend_analysis['hyper_efficiency']  # ãƒã‚¤ãƒ‘ãƒ¼åŠ¹ç‡ç‡
quantum_coherence = trend_analysis['quantum_coherence'] # é‡å­ã‚³ãƒ’ãƒ¼ãƒ¬ãƒ³ã‚¹
market_regime = trend_analysis['market_regime']        # å¸‚å ´ãƒ¬ã‚¸ãƒ¼ãƒ 
```

### çŸ¥èƒ½ãƒ¬ãƒãƒ¼ãƒˆ

```python
# ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ çŸ¥èƒ½ãƒ¬ãƒãƒ¼ãƒˆã®å–å¾—
intelligence_report = ubc.get_intelligence_report()

print(f"ç¾åœ¨ãƒˆãƒ¬ãƒ³ãƒ‰: {intelligence_report['current_trend']}")
print(f"ç¾åœ¨ãƒ¬ã‚¸ãƒ¼ãƒ : {intelligence_report['current_regime']}")
print(f"ãƒˆãƒ¬ãƒ³ãƒ‰å¼·åº¦: {intelligence_report['trend_strength']:.3f}")
print(f"ã‚·ã‚¹ãƒ†ãƒ åŠ¹ç‡: {intelligence_report['system_efficiency']:.3f}")
```

### è¤‡åˆæˆ¦ç•¥

```python
# è¤‡æ•°æ™‚é–“è»¸ã§ã®çµ±åˆåˆ†æ
ubc_h1 = UltimateBreakoutChannel(atr_period=14, base_multiplier=2.0)
ubc_h4 = UltimateBreakoutChannel(atr_period=21, base_multiplier=1.8)
ubc_d1 = UltimateBreakoutChannel(atr_period=21, base_multiplier=2.2)

result_h1 = ubc_h1.calculate(data_h1)
result_h4 = ubc_h4.calculate(data_h4)
result_d1 = ubc_d1.calculate(data_d1)

# çµ±åˆã‚·ã‚°ãƒŠãƒ«åˆ¤å®š
def integrated_signal(r_h1, r_h4, r_d1):
    # è¤‡æ•°æ™‚é–“è»¸ã§ã®åˆæ„ã«åŸºã¥ãã‚·ã‚°ãƒŠãƒ«ç”Ÿæˆ
    h1_signal = r_h1.breakout_signals[-1]
    h4_signal = r_h4.breakout_signals[-1]
    d1_signal = r_d1.breakout_signals[-1]
    
    # çµ±åˆãƒ­ã‚¸ãƒƒã‚¯
    if h1_signal == h4_signal == d1_signal and h1_signal != 0:
        return h1_signal  # å…¨æ™‚é–“è»¸ã§åˆæ„
    elif h4_signal == d1_signal and h4_signal != 0:
        return h4_signal  # ä¸Šä½æ™‚é–“è»¸ã§åˆæ„
    else:
        return 0  # åˆæ„ãªã—
```

## ğŸš¨ æ³¨æ„äº‹é …ã¨ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

1. **ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚º**: å¤§ããªãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆï¼ˆ>5000ãƒã‚¤ãƒ³ãƒˆï¼‰ã§ã¯åˆ†å‰²å‡¦ç†ã‚’æ¨å¥¨
2. **ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ´»ç”¨**: åŒã˜ãƒ‡ãƒ¼ã‚¿ã§ã®å†è¨ˆç®—æ™‚ã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãŒè‡ªå‹•åˆ©ç”¨ã•ã‚Œã‚‹
3. **ãƒ¡ãƒ¢ãƒªç®¡ç†**: é•·æœŸé–“ä½¿ç”¨æ™‚ã¯å®šæœŸçš„ã«`reset()`ã‚’å‘¼ã³å‡ºã—

### ãƒˆãƒ¬ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°å®Ÿè£…

1. **ã‚·ã‚°ãƒŠãƒ«å“è³ªãƒ•ã‚£ãƒ«ã‚¿ãƒ¼**: å¿…ãš`signal_quality`ã‚’ç¢ºèªã—ã¦ã‹ã‚‰å–å¼•å®Ÿè¡Œ
2. **å¸‚å ´ãƒ¬ã‚¸ãƒ¼ãƒ è€ƒæ…®**: `market_regime`ã«åŸºã¥ããƒã‚¸ã‚·ãƒ§ãƒ³ã‚µã‚¤ã‚ºèª¿æ•´
3. **è¤‡æ•°ç¢ºèª**: ä»–ã®ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã¨ã®çµ„ã¿åˆã‚ã›ä½¿ç”¨ã‚’æ¨å¥¨

### ãƒªã‚¹ã‚¯ç®¡ç†

```python
def safe_trading_signal(result, min_quality=0.5, min_trend_strength=0.4):
    """å®‰å…¨ãªãƒˆãƒ¬ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚·ã‚°ãƒŠãƒ«åˆ¤å®š"""
    latest_signal = result.breakout_signals[-1]
    latest_quality = result.signal_quality[-1]
    latest_trend = result.trend_strength[-1]
    
    if (latest_signal != 0 and 
        latest_quality >= min_quality and 
        latest_trend >= min_trend_strength):
        return latest_signal
    else:
        return 0  # ã‚·ã‚°ãƒŠãƒ«ãªã—
```

## ğŸ“Š ãƒãƒƒã‚¯ãƒ†ã‚¹ãƒˆçµ±åˆ

### åŸºæœ¬ãƒãƒƒã‚¯ãƒ†ã‚¹ãƒˆ

```python
def backtest_ubc(price_data, initial_capital=10000):
    """UBCãƒãƒƒã‚¯ãƒ†ã‚¹ãƒˆã‚µãƒ³ãƒ—ãƒ«"""
    ubc = UltimateBreakoutChannel()
    result = ubc.calculate(price_data)
    
    capital = initial_capital
    position = 0
    trades = []
    
    for i in range(len(result.breakout_signals)):
        signal = result.breakout_signals[i]
        quality = result.signal_quality[i]
        price = price_data['close'].iloc[i]
        
        if signal != 0 and quality >= 0.4:
            if position == 0:  # ã‚¨ãƒ³ãƒˆãƒªãƒ¼
                position = signal
                entry_price = price
                trades.append({'type': 'entry', 'signal': signal, 'price': price, 'time': i})
            elif position != signal:  # åè»¢
                # æ—¢å­˜ãƒã‚¸ã‚·ãƒ§ãƒ³æ±ºæ¸ˆ
                pnl = (price - entry_price) * position
                capital += pnl
                trades.append({'type': 'exit', 'pnl': pnl, 'price': price, 'time': i})
                
                # æ–°è¦ãƒã‚¸ã‚·ãƒ§ãƒ³
                position = signal
                entry_price = price
                trades.append({'type': 'entry', 'signal': signal, 'price': price, 'time': i})
    
    return {'final_capital': capital, 'trades': trades, 'return_pct': (capital - initial_capital) / initial_capital * 100}
```

## ğŸ”§ ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### ã‚ˆãã‚ã‚‹å•é¡Œ

1. **NaNå€¤ã®å¤§é‡ç™ºç”Ÿ**
   - åŸå› : ãƒ‡ãƒ¼ã‚¿ã®ä¸è¶³ã¾ãŸã¯å“è³ªå•é¡Œ
   - è§£æ±º: ãƒ‡ãƒ¼ã‚¿ã‚’ç¢ºèªã—ã€æœ€ä½50ãƒã‚¤ãƒ³ãƒˆä»¥ä¸Šã‚’ä½¿ç”¨

2. **ã‚·ã‚°ãƒŠãƒ«ãŒç”Ÿæˆã•ã‚Œãªã„**
   - åŸå› : `min_signal_quality`ãŒé«˜ã™ãã‚‹
   - è§£æ±º: ã—ãã„å€¤ã‚’0.2-0.4ã«èª¿æ•´

3. **è¨ˆç®—é€Ÿåº¦ãŒé…ã„**
   - åŸå› : ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚ºãŒå¤§ãã™ãã‚‹
   - è§£æ±º: ãƒ‡ãƒ¼ã‚¿ã‚’åˆ†å‰²ã¾ãŸã¯æœŸé–“ã‚’çŸ­ç¸®

### ãƒ‡ãƒãƒƒã‚°æ–¹æ³•

```python
# ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã®è¡¨ç¤º
def debug_ubc(ubc, data):
    result = ubc.calculate(data)
    
    print(f"ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆæ•°: {len(data)}")
    print(f"æœ‰åŠ¹ãªãƒãƒ£ãƒãƒ«ãƒã‚¤ãƒ³ãƒˆæ•°: {np.sum(~np.isnan(result.upper_channel))}")
    print(f"ã‚·ã‚°ãƒŠãƒ«æ•°: {int(np.sum(np.abs(result.breakout_signals)))}")
    print(f"å¹³å‡ã‚·ã‚°ãƒŠãƒ«å“è³ª: {np.nanmean(result.signal_quality[result.signal_quality > 0]):.3f}")
    print(f"ãƒˆãƒ¬ãƒ³ãƒ‰å¼·åº¦ç¯„å›²: {np.nanmin(result.trend_strength):.3f} - {np.nanmax(result.trend_strength):.3f}")
```

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Hilbert Transform in Signal Processing - Alan V. Oppenheim
2. Kalman Filter Theory and Practice - Mohinder S. Grewal
3. Wavelets and Filter Banks - Gilbert Strang
4. Efficiency Ratio in Financial Markets - Perry Kaufman
5. Quantum Coherence in Market Dynamics - Modern Portfolio Theory Extensions

## ğŸ¤ ã‚µãƒãƒ¼ãƒˆ

æŠ€è¡“çš„ãªè³ªå•ã‚„ãƒã‚°ãƒ¬ãƒãƒ¼ãƒˆã«ã¤ã„ã¦ã¯ã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®GitHubãƒªãƒã‚¸ãƒˆãƒªã«ã¦Issueã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚

---

**Ultimate Breakout Channel** - äººé¡å²ä¸Šæœ€å¼·ã®ãƒ–ãƒ¬ã‚¤ã‚¯ã‚¢ã‚¦ãƒˆãƒãƒ£ãƒãƒ«ã§ã€ç©¶æ¥µã®ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ•ã‚©ãƒ­ãƒ¼æˆ¦ç•¥ã‚’å®Ÿç¾ã—ã¾ã—ã‚‡ã†ï¼ ğŸš€ 