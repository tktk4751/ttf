#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
UltimateMA V3 Real Data Demo with Matplotlib Visualization
ÂÆüÈöõ„ÅÆBinance„Éá„Éº„Çø„ÇíÁõ¥Êé•Ë™≠„ÅøËæº„Çì„Åß„ÉÜ„Çπ„Éà„Åó„ÄÅ„ÉÅ„É£„Éº„Éà„ÅßÂèØË¶ñÂåñ„Åô„Çã„Éá„É¢
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from datetime import datetime, timedelta
import os
import sys
import time
import warnings
warnings.filterwarnings('ignore')

# matplotlib„ÅÆ„Éï„Ç©„É≥„ÉàË≠¶Âëä„ÇíÁÑ°ÂäπÂåñ
import matplotlib
matplotlib.rcParams['font.family'] = 'DejaVu Sans'
import logging
logging.getLogger('matplotlib.font_manager').setLevel(logging.ERROR)

# UltimateMA V3„ÅÆ„Ç§„É≥„Éù„Éº„Éà
from ultimate_ma_v3 import UltimateMAV3


def load_binance_data(symbol='BTC', market_type='spot', timeframe='4h', data_dir='data/binance'):
    """
    Binance„Éá„Éº„Çø„ÇíÁõ¥Êé•Ë™≠„ÅøËæº„ÇÄ
    
    Args:
        symbol: „Ç∑„É≥„Éú„É´Âêç (BTC, ETH, etc.)
        market_type: Â∏ÇÂ†¥„Çø„Ç§„Éó (spot, future)
        timeframe: ÊôÇÈñìË∂≥ (1h, 4h, 1d, etc.)
        data_dir: „Éá„Éº„Çø„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅÆ„Éë„Çπ
    
    Returns:
        pd.DataFrame: OHLCV„Éá„Éº„Çø
    """
    # ÁèæÂú®„ÅÆ„Éá„Ç£„É¨„ÇØ„Éà„É™„Ååindicators„ÅÆÂ†¥Âêà„ÄÅ‰∏Ä„Å§‰∏ä„Å´ÁßªÂãï
    if os.path.basename(os.getcwd()) == 'indicators':
        data_dir = f"../{data_dir}"
    
    file_path = f"{data_dir}/{symbol}/{market_type}/{timeframe}/historical_data.csv"
    
    print(f"üìÇ „Éá„Éº„Çø„Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„Åø‰∏≠: {file_path}")
    
    if not os.path.exists(file_path):
        print(f"‚ùå „Éá„Éº„Çø„Éï„Ç°„Ç§„É´„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì: {file_path}")
        return None
    
    try:
        # CSV„Éï„Ç°„Ç§„É´„ÇíË™≠„ÅøËæº„Åø
        df = pd.read_csv(file_path)
        
        # „Çø„Ç§„É†„Çπ„Çø„É≥„Éó„Çí„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Å´Ë®≠ÂÆö
        if 'timestamp' in df.columns:
            df['timestamp'] = pd.to_datetime(df['timestamp'])
            df.set_index('timestamp', inplace=True)
        
        # ÂøÖË¶Å„Å™„Ç´„É©„É†„ÅåÂ≠òÂú®„Åô„Çã„ÅãÁ¢∫Ë™ç
        required_columns = ['open', 'high', 'low', 'close']
        missing_columns = [col for col in required_columns if col not in df.columns]
        
        if missing_columns:
            print(f"‚ùå ÂøÖË¶Å„Å™„Ç´„É©„É†„Åå‰∏çË∂≥„Åó„Å¶„ÅÑ„Åæ„Åô: {missing_columns}")
            return None
        
        # „Éá„Éº„ÇøÂûã„ÇíÊï∞ÂÄ§„Å´Â§âÊèõ
        for col in required_columns:
            df[col] = pd.to_numeric(df[col], errors='coerce')
        
        # NaN„ÇíÈô§Âéª
        df = df.dropna()
        
        print(f"‚úÖ „Éá„Éº„ÇøË™≠„ÅøËæº„ÅøÊàêÂäü: {symbol} {market_type} {timeframe}")
        print(f"üìä „Éá„Éº„ÇøÊúüÈñì: {df.index.min()} - {df.index.max()}")
        print(f"üìà „Éá„Éº„ÇøÊï∞: {len(df)}‰ª∂")
        print(f"üí∞ ‰æ°Ê†ºÁØÑÂõ≤: {df['close'].min():.2f} - {df['close'].max():.2f}")
        
        return df
        
    except Exception as e:
        print(f"‚ùå „Éá„Éº„ÇøË™≠„ÅøËæº„Åø„Ç®„É©„Éº: {e}")
        return None


def plot_ultimate_ma_v3_real_data(data: pd.DataFrame, result, symbol: str, save_path: str = None):
    """
    ÂÆüÈöõ„ÅÆBinance„Éá„Éº„Çø„Åß„ÅÆUltimateMA V3ÁµêÊûú„ÇíÂåÖÊã¨ÁöÑ„Å´ÂèØË¶ñÂåñ
    
    Args:
        data: ÂÖÉ„ÅÆOHLC„Éá„Éº„Çø
        result: UltimateMA V3„ÅÆË®àÁÆóÁµêÊûú
        symbol: „Ç∑„É≥„Éú„É´Âêç
        save_path: ‰øùÂ≠ò„Éë„ÇπÔºàNone„ÅÆÂ†¥Âêà„ÅØËá™ÂãïÁîüÊàêÔºâ
    """
    n_points = len(data)
    print(f"üìä {symbol} UltimateMA V3„ÉÅ„É£„Éº„ÉàÊèèÁîª‰∏≠... „Éá„Éº„ÇøÁÇπÊï∞: {n_points}")
    
    # ÊôÇÁ≥ªÂàó„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÅÆÊ∫ñÂÇô
    x_axis = data.index
    use_datetime = True
    
    # Âõ≥„ÅÆ‰ΩúÊàêÔºà8„Å§„ÅÆ„Çµ„Éñ„Éó„É≠„ÉÉ„ÉàÔºâ
    fig, axes = plt.subplots(8, 1, figsize=(20, 28))
    
    title = f'üöÄ UltimateMA V3 - {symbol} Real Binance Data Analysis\nüìä ÂÆüÈöõ„ÅÆÁõ∏Â†¥„Éá„Éº„Çø ({n_points}‰ª∂) | ÊúüÈñì: {data.index.min().strftime("%Y-%m-%d")} - {data.index.max().strftime("%Y-%m-%d")}'
    fig.suptitle(title, fontsize=16, fontweight='bold', y=0.98)
    
    # 1. ‰æ°Ê†º„ÉÅ„É£„Éº„Éà„Å®UltimateMA V3
    ax1 = axes[0]
    
    # „É≠„Éº„ÇΩ„ÇØË∂≥È¢®„ÅÆ‰æ°Ê†ºË°®Á§∫
    ax1.plot(x_axis, data['high'], color='lightgray', alpha=0.3, linewidth=0.5, label='High')
    ax1.plot(x_axis, data['low'], color='lightgray', alpha=0.3, linewidth=0.5, label='Low')
    ax1.plot(x_axis, data['close'], color='black', alpha=0.7, linewidth=1.0, label='Close Price')
    
    # UltimateMA V3„É©„Ç§„É≥
    ax1.plot(x_axis, result.values, color='blue', linewidth=2.0, label='UltimateMA V3', alpha=0.9)
    
    # „Éà„É¨„É≥„ÉâËÉåÊôØËâ≤
    try:
        signals = result.trend_signals
        if len(signals) > 0:
            current_signal = signals[0]
            start_idx = 0
            
            for i in range(1, len(signals) + 1):
                if i == len(signals) or signals[i] != current_signal:
                    end_idx = i - 1
                    
                    if current_signal == 1:  # ‰∏äÊòá„Éà„É¨„É≥„Éâ
                        color = 'lightgreen'
                        alpha = 0.15
                    elif current_signal == -1:  # ‰∏ãÈôç„Éà„É¨„É≥„Éâ
                        color = 'lightcoral'
                        alpha = 0.15
                    else:  # „É¨„É≥„Ç∏
                        color = 'lightyellow'
                        alpha = 0.1
                    
                    if start_idx < len(x_axis) and end_idx < len(x_axis):
                        ax1.axvspan(x_axis[start_idx], x_axis[end_idx], color=color, alpha=alpha, zorder=0)
                    
                    if i < len(signals):
                        start_idx = i
                        current_signal = signals[i]
    except Exception as e:
        print(f"‚ö†Ô∏è  ËÉåÊôØËâ≤Ë®≠ÂÆö„Åß„Ç®„É©„Éº: {e}")
    
    ax1.set_title(f'üí∞ {symbol} Price Chart with UltimateMA V3 (Green=Up, Red=Down, Yellow=Range)', fontsize=14, fontweight='bold')
    ax1.set_ylabel('Price (USD)', fontsize=12)
    ax1.legend(loc='upper left')
    ax1.grid(True, alpha=0.3)
    
    # 2. ‰ø°È†ºÂ∫¶„Å®„Éà„É¨„É≥„ÉâÂº∑Â∫¶
    ax2 = axes[1]
    
    # ‰ø°È†ºÂ∫¶„Çí„Ç´„É©„Éº„Éû„ÉÉ„Éó„ÅßË°®Á§∫
    scatter = ax2.scatter(x_axis, result.trend_confidence, c=result.trend_confidence, 
                         cmap='viridis', alpha=0.7, s=12, zorder=2)
    ax2.plot(x_axis, result.trend_confidence, color='orange', alpha=0.5, linewidth=1.0, zorder=1)
    
    # ‰ø°È†ºÂ∫¶ÈñæÂÄ§„É©„Ç§„É≥
    ax2.axhline(y=0.5, color='red', linestyle='--', alpha=0.7, label='High Confidence (0.5)')
    ax2.axhline(y=0.7, color='green', linestyle='--', alpha=0.7, label='Ultra Confidence (0.7)')
    
    ax2.set_title('üî• Trend Confidence Levels', fontsize=14, fontweight='bold')
    ax2.set_ylabel('Confidence Level', fontsize=12)
    ax2.legend(loc='upper right')
    ax2.grid(True, alpha=0.3)
    
    # „Ç´„É©„Éº„Éê„Éº„ÅÆËøΩÂä†
    cbar = plt.colorbar(scatter, ax=ax2)
    cbar.set_label('Confidence Level', fontsize=10)
    
    # 3. ÈáèÂ≠êÁä∂ÊÖã„Å®MTFÂêàÊÑèÂ∫¶
    ax3 = axes[2]
    ax3.plot(x_axis, result.quantum_state, label='üåå Quantum State', color='purple', linewidth=1.5, alpha=0.8)
    ax3_twin = ax3.twinx()
    ax3_twin.plot(x_axis, result.multi_timeframe_consensus, label='üîÑ MTF Consensus', color='blue', linewidth=1.2, alpha=0.7)
    
    ax3.axhline(y=0, color='gray', linestyle='-', alpha=0.5)
    ax3_twin.axhline(y=0.8, color='green', linestyle='--', alpha=0.5, label='Strong Consensus (0.8)')
    
    ax3.set_title('üåå Quantum State & Multi-Timeframe Consensus', fontsize=14, fontweight='bold')
    ax3.set_ylabel('Quantum State', fontsize=12, color='purple')
    ax3_twin.set_ylabel('MTF Consensus', fontsize=12, color='blue')
    ax3.legend(loc='upper left')
    ax3_twin.legend(loc='upper right')
    ax3.grid(True, alpha=0.3)
    
    # 4. „Éï„É©„ÇØ„Çø„É´Ê¨°ÂÖÉ„Å®„Ç®„É≥„Éà„É≠„Éî„Éº
    ax4 = axes[3]
    ax4.plot(x_axis, result.fractal_dimension, label='üåÄ Fractal Dimension', color='green', linewidth=1.5, alpha=0.8)
    ax4_twin = ax4.twinx()
    ax4_twin.plot(x_axis, result.entropy_level, label='üî¨ Entropy Level', color='red', linewidth=1.2, alpha=0.7)
    
    # ÁêÜÊÉ≥ÁöÑ„Å™ÂÄ§„ÅÆ„É©„Ç§„É≥
    ax4.axhline(y=1.0, color='green', linestyle='--', alpha=0.5, label='Ideal Fractal (1.0)')
    ax4_twin.axhline(y=0.5, color='red', linestyle='--', alpha=0.5, label='Medium Entropy (0.5)')
    
    ax4.set_title('üåÄ Fractal Dimension & Entropy Analysis', fontsize=14, fontweight='bold')
    ax4.set_ylabel('Fractal Dimension', fontsize=12, color='green')
    ax4_twin.set_ylabel('Entropy Level', fontsize=12, color='red')
    ax4.legend(loc='upper left')
    ax4_twin.legend(loc='upper right')
    ax4.grid(True, alpha=0.3)
    
    # 5. „Éú„É©„ÉÜ„Ç£„É™„ÉÜ„Ç£„É¨„Ç∏„Éº„É†
    ax5 = axes[4]
    
    # „Éú„É©„ÉÜ„Ç£„É™„ÉÜ„Ç£„É¨„Ç∏„Éº„É†„ÇíËâ≤ÂàÜ„ÅëË°®Á§∫
    regime_colors = {0: 'blue', 1: 'green', 2: 'red'}
    regime_labels = {0: '‰Ωé„Éú„É©„ÉÜ„Ç£„É™„ÉÜ„Ç£', 1: 'Ê≠£Â∏∏', 2: 'È´ò„Éú„É©„ÉÜ„Ç£„É™„ÉÜ„Ç£'}
    
    for regime_value in [0, 1, 2]:
        mask = result.volatility_regime == regime_value
        if np.any(mask):
            ax5.scatter(np.array(x_axis)[mask], data['close'].values[mask], 
                       c=regime_colors[regime_value], label=regime_labels[regime_value], 
                       alpha=0.6, s=8)
    
    ax5.plot(x_axis, data['close'], color='black', alpha=0.3, linewidth=0.8)
    ax5.set_title('üìä Volatility Regime Detection', fontsize=14, fontweight='bold')
    ax5.set_ylabel('Price (USD)', fontsize=12)
    ax5.legend(loc='upper left')
    ax5.grid(True, alpha=0.3)
    
    # 6. „Éí„É´„Éô„É´„ÉàÂ§âÊèõ - ÊåØÂπÖ„Å®‰ΩçÁõ∏
    ax6 = axes[5]
    ax6.plot(x_axis, result.amplitude, label='Instantaneous Amplitude', color='purple', linewidth=1.2, alpha=0.8)
    ax6_twin = ax6.twinx()
    ax6_twin.plot(x_axis, result.phase, label='Instantaneous Phase', color='orange', linewidth=1.0, alpha=0.7)
    
    # „Éé„Ç§„Ç∫ÈñæÂÄ§
    if len(result.amplitude) > 0:
        noise_threshold = np.mean(result.amplitude) * 0.3
        ax6.axhline(y=noise_threshold, color='red', linestyle='--', alpha=0.7, 
                   label=f'Noise Threshold ({noise_threshold:.1f})')
    
    ax6.set_title('üåÄ Hilbert Transform - Amplitude & Phase', fontsize=14, fontweight='bold')
    ax6.set_ylabel('Amplitude', fontsize=12, color='purple')
    ax6_twin.set_ylabel('Phase (radians)', fontsize=12, color='orange')
    ax6.legend(loc='upper left')
    ax6_twin.legend(loc='upper right')
    ax6.grid(True, alpha=0.3)
    
    # 7. „É™„Ç¢„É´„Çø„Ç§„É†„Éà„É¨„É≥„ÉâÊ§úÂá∫
    ax7 = axes[6]
    positive_mask = result.realtime_trends > 0
    negative_mask = result.realtime_trends < 0
    
    ax7.fill_between(x_axis, 0, result.realtime_trends, where=positive_mask, 
                    color='green', alpha=0.6, label='Bullish Trend')
    ax7.fill_between(x_axis, 0, result.realtime_trends, where=negative_mask, 
                    color='red', alpha=0.6, label='Bearish Trend')
    ax7.plot(x_axis, result.realtime_trends, color='black', linewidth=0.8, alpha=0.7)
    
    ax7.axhline(y=0, color='gray', linestyle='-', alpha=0.5)
    ax7.set_title('‚ö° Real-Time Trend Detector', fontsize=14, fontweight='bold')
    ax7.set_ylabel('Trend Strength', fontsize=12)
    ax7.legend(loc='upper right')
    ax7.grid(True, alpha=0.3)
    
    # 8. Áµ±ÂêàÂàÜÊûê„Çµ„Éû„É™„ÉºÔºàÊúÄÊñ∞„ÅÆÁµ±Ë®àÔºâ
    ax8 = axes[7]
    
    # ÊúÄÊñ∞„ÅÆÂàÜÊûêÊåáÊ®ô
    latest_confidence = result.trend_confidence[-1] if len(result.trend_confidence) > 0 else 0
    latest_quantum = result.quantum_state[-1] if len(result.quantum_state) > 0 else 0
    latest_mtf = result.multi_timeframe_consensus[-1] if len(result.multi_timeframe_consensus) > 0 else 0
    latest_fractal = result.fractal_dimension[-1] if len(result.fractal_dimension) > 0 else 0
    latest_entropy = result.entropy_level[-1] if len(result.entropy_level) > 0 else 0
    
    metrics = [
        latest_confidence,
        latest_mtf,
        1.0 - latest_entropy,  # ‰∫àÊ∏¨ÂèØËÉΩÊÄß
        min(1.0, abs(latest_quantum) * 2),  # ÈáèÂ≠êÂº∑Â∫¶ÔºàÊ≠£Ë¶èÂåñÔºâ
        latest_fractal
    ]
    
    metric_names = ['Current\nConfidence', 'MTF\nConsensus', 'Predictability', 'Quantum\nStrength', 'Fractal\nDimension']
    colors = ['red', 'blue', 'green', 'purple', 'orange']
    
    bars = ax8.bar(metric_names, metrics, color=colors, alpha=0.7)
    ax8.set_title(f'üéØ {symbol} Current Analysis Summary', fontsize=14, fontweight='bold')
    ax8.set_ylabel('Score (0-1)', fontsize=12)
    ax8.set_ylim(0, 1)
    
    # ÂÄ§„Çí„Éê„Éº„ÅÆ‰∏ä„Å´Ë°®Á§∫
    for bar, metric in zip(bars, metrics):
        height = bar.get_height()
        ax8.text(bar.get_x() + bar.get_width()/2., height + 0.01,
                f'{metric:.3f}', ha='center', va='bottom', fontsize=10, fontweight='bold')
    
    ax8.grid(True, alpha=0.3)
    plt.setp(ax8.get_xticklabels(), rotation=0, ha='center')
    
    # XËª∏„ÅÆË®≠ÂÆöÔºàÊó•‰ªò„Éï„Ç©„Éº„Éû„ÉÉ„ÉàÔºâ
    for ax in axes[:-1]:  # ÊúÄÂæå„ÅÆ„Çµ„Éû„É™„Éº„ÉÅ„É£„Éº„Éà‰ª•Â§ñ
        ax.tick_params(axis='x', rotation=45)
        if use_datetime:
            ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
            ax.xaxis.set_major_locator(mdates.MonthLocator(interval=2))
    
    axes[-1].set_xlabel('Analysis Metrics', fontsize=12)
    
    # „É¨„Ç§„Ç¢„Ç¶„ÉàË™øÊï¥
    plt.tight_layout()
    plt.subplots_adjust(top=0.96)
    
    # Áµ±Ë®àÊÉÖÂ†±„Çí„ÉÜ„Ç≠„Çπ„Éà„ÅßËøΩÂä†
    noise_reduction = ((np.nanstd(result.raw_values) - np.nanstd(result.values)) / 
                      np.nanstd(result.raw_values) * 100) if np.nanstd(result.raw_values) > 0 else 0
    
    confident_signals = result.trend_confidence[result.trend_confidence > 0]
    avg_confidence = np.mean(confident_signals) if len(confident_signals) > 0 else 0
    
    up_signals = np.sum(result.trend_signals == 1)
    down_signals = np.sum(result.trend_signals == -1)
    range_signals = np.sum(result.trend_signals == 0)
    
    stats_text = f"""{symbol} UltimateMA V3 - Real Data Analysis:
Current Trend: {result.current_trend.upper()} (Confidence: {result.current_confidence:.3f})
Data Period: {data.index.min().strftime('%Y-%m-%d')} - {data.index.max().strftime('%Y-%m-%d')}
Data Points: {len(data)} | Price Range: ${data['close'].min():.2f} - ${data['close'].max():.2f}
Noise Reduction: {noise_reduction:.1f}% | Average Confidence: {avg_confidence:.3f}
Trend Distribution: Up {up_signals}({up_signals/len(data)*100:.1f}%) | Down {down_signals}({down_signals/len(data)*100:.1f}%) | Range {range_signals}({range_signals/len(data)*100:.1f}%)
Quantum State: {np.mean(result.quantum_state):.3f} | MTF Consensus: {np.mean(result.multi_timeframe_consensus):.3f}
Fractal Dimension: {np.mean(result.fractal_dimension):.3f} | Entropy: {np.mean(result.entropy_level):.3f}"""
    
    fig.text(0.02, 0.02, stats_text, fontsize=9, 
             bbox=dict(boxstyle="round,pad=0.3", facecolor="lightblue", alpha=0.8))
    
    # „Éï„Ç°„Ç§„É´‰øùÂ≠ò
    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight', facecolor='white')
        print(f"‚úÖ {symbol} UltimateMA V3„ÉÅ„É£„Éº„Éà‰øùÂ≠òÂÆå‰∫Ü ({save_path})")
    else:
        filename = f"ultimate_ma_v3_{symbol.lower()}_real_data_analysis.png"
        plt.savefig(filename, dpi=300, bbox_inches='tight', facecolor='white')
        print(f"‚úÖ {symbol} UltimateMA V3„ÉÅ„É£„Éº„Éà‰øùÂ≠òÂÆå‰∫Ü ({filename})")
    
    plt.show()  # „ÉÅ„É£„Éº„Éà„ÇíË°®Á§∫
    plt.close()


def analyze_ultimate_ma_v3_performance(result) -> dict:
    """UltimateMA V3„ÅÆ„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÂàÜÊûê"""
    # Âü∫Êú¨„Éé„Ç§„Ç∫Èô§ÂéªÂäπÊûú
    raw_std = np.nanstd(result.raw_values)
    final_std = np.nanstd(result.values)
    noise_reduction_ratio = (raw_std - final_std) / raw_std if raw_std > 0 else 0.0
    
    # „Éà„É¨„É≥„ÉâÁµ±Ë®à
    trend_signals = result.trend_signals
    up_periods = np.sum(trend_signals == 1)
    down_periods = np.sum(trend_signals == -1)
    range_periods = np.sum(trend_signals == 0)
    total_periods = len(trend_signals)
    
    # ‰ø°È†ºÂ∫¶Áµ±Ë®à
    confident_signals = result.trend_confidence[result.trend_confidence > 0]
    high_confidence_signals = result.trend_confidence[result.trend_confidence > 0.5]
    ultra_confidence_signals = result.trend_confidence[result.trend_confidence > 0.7]
    
    # ÈáèÂ≠êÂàÜÊûêÁµ±Ë®à
    quantum_stats = {
        'mean_quantum_state': np.nanmean(result.quantum_state),
        'quantum_strength': np.nanmean(np.abs(result.quantum_state)),
        'mtf_consensus_avg': np.nanmean(result.multi_timeframe_consensus),
        'fractal_dimension_avg': np.nanmean(result.fractal_dimension),
        'entropy_level_avg': np.nanmean(result.entropy_level),
        'predictability': 1.0 - np.nanmean(result.entropy_level)
    }
    
    return {
        'noise_reduction': {
            'raw_volatility': raw_std,
            'filtered_volatility': final_std,
            'reduction_ratio': noise_reduction_ratio,
            'reduction_percentage': noise_reduction_ratio * 100
        },
        'trend_analysis': {
            'total_periods': total_periods,
            'up_periods': up_periods,
            'down_periods': down_periods,
            'range_periods': range_periods,
            'up_ratio': up_periods / total_periods if total_periods > 0 else 0,
            'down_ratio': down_periods / total_periods if total_periods > 0 else 0,
            'range_ratio': range_periods / total_periods if total_periods > 0 else 0,
            'current_trend': result.current_trend,
            'current_confidence': result.current_confidence
        },
        'confidence_analysis': {
            'total_confident_signals': len(confident_signals),
            'high_confidence_signals': len(high_confidence_signals),
            'ultra_confidence_signals': len(ultra_confidence_signals),
            'avg_confidence': np.mean(confident_signals) if len(confident_signals) > 0 else 0,
            'max_confidence': np.max(result.trend_confidence),
            'confidence_ratio': len(confident_signals) / total_periods if total_periods > 0 else 0
        },
        'quantum_analysis': quantum_stats
    }


def test_with_visualization(symbol='BTC', n_points=1000):
    """ÊåáÂÆö„Åï„Çå„Åü„Ç∑„É≥„Éú„É´„Åß„ÉÜ„Çπ„Éà„Åó„ÄÅÂèØË¶ñÂåñ„Åô„Çã"""
    print(f"\n{'='*20} {symbol} ÂèØË¶ñÂåñ„ÉÜ„Çπ„Éà {'='*20}")
    
    # „Éá„Éº„ÇøË™≠„ÅøËæº„Åø
    data = load_binance_data(symbol=symbol, market_type='spot', timeframe='4h')
    
    if data is None:
        print(f"‚ùå {symbol}„ÅÆ„Éá„Éº„ÇøË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü")
        return None
    
    # ÊåáÂÆö„Åï„Çå„Åü‰ª∂Êï∞„ÅÆ„Éá„Éº„Çø„Çí‰ΩøÁî®
    if len(data) > n_points:
        data = data.tail(n_points)
        print(f"üìä ÊúÄÊñ∞{n_points}‰ª∂„ÅÆ„Éá„Éº„Çø„Çí‰ΩøÁî®: {data.index.min()} - {data.index.max()}")
    
    # UltimateMA V3ÂàùÊúüÂåñ
    uma_v3 = UltimateMAV3(
        super_smooth_period=8,
        zero_lag_period=16,
        realtime_window=34,
        quantum_window=16,
        fractal_window=16,
        entropy_window=16,
        src_type='hlc3',
        slope_index=2,
        base_threshold=0.002,
        min_confidence=0.15
    )
    
    # Ë®àÁÆóÂÆüË°å
    print(f"‚ö° {symbol} UltimateMA V3Ë®àÁÆóÂÆüË°å‰∏≠...")
    start_time = time.time()
    result = uma_v3.calculate(data)
    calc_time = time.time() - start_time
    
    print(f"‚úÖ {symbol} Ë®àÁÆóÂÆå‰∫Ü (ÊôÇÈñì: {calc_time:.2f}Áßí, ÈÄüÂ∫¶: {len(data)/calc_time:.0f} „Éá„Éº„Çø/Áßí)")
    
    # „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÂàÜÊûê
    performance = analyze_ultimate_ma_v3_performance(result)
    
    # ÁµêÊûúË°®Á§∫
    noise_stats = performance['noise_reduction']
    trend_stats = performance['trend_analysis']
    conf_stats = performance['confidence_analysis']
    quantum_stats = performance['quantum_analysis']
    
    print(f"\nüìä {symbol} ÁµêÊûú„Çµ„Éû„É™„Éº:")
    print(f"   ÁèæÂú®„ÅÆ„Éà„É¨„É≥„Éâ: {trend_stats['current_trend'].upper()} (‰ø°È†ºÂ∫¶: {trend_stats['current_confidence']:.3f})")
    print(f"   „Éé„Ç§„Ç∫Èô§ÂéªÁéá: {noise_stats['reduction_percentage']:.1f}%")
    print(f"   Âπ≥Âùá‰ø°È†ºÂ∫¶: {conf_stats['avg_confidence']:.3f}")
    print(f"   ÈáèÂ≠êÂº∑Â∫¶: {quantum_stats['quantum_strength']:.3f}")
    print(f"   MTFÂêàÊÑèÂ∫¶: {quantum_stats['mtf_consensus_avg']:.3f}")
    print(f"   ‰∫àÊ∏¨ÂèØËÉΩÊÄß: {quantum_stats['predictability']:.3f}")
    
    # „ÉÅ„É£„Éº„ÉàÊèèÁîª
    print(f"\nüìä {symbol} „ÉÅ„É£„Éº„ÉàÊèèÁîª‰∏≠...")
    plot_ultimate_ma_v3_real_data(data, result, symbol)
    
    return {
        'data': data,
        'result': result,
        'performance': performance
    }


def main():
    print("üöÄ UltimateMA V3 - Real Binance Data Demo with Matplotlib Visualization")
    print("ÈáèÂ≠ê„Éã„É•„Éº„É©„É´„Éª„Éï„É©„ÇØ„Çø„É´„Éª„Ç®„É≥„Éà„É≠„Éî„ÉºÁµ±ÂêàÂàÜÊûê„Ç∑„Çπ„ÉÜ„É†")
    print("ÂÆüÈöõ„ÅÆBinance„Éá„Éº„Çø„Åß„ÅÆ„ÉÜ„Çπ„Éà + „ÉÅ„É£„Éº„ÉàÂèØË¶ñÂåñ")
    print("="*80)
    
    # Âà©Áî®ÂèØËÉΩ„Å™„Ç∑„É≥„Éú„É´
    available_symbols = ['BTC', 'ETH', 'ADA', 'ATOM', 'AVAX']
    
    print(f"\nüìä Âà©Áî®ÂèØËÉΩ„Å™„Ç∑„É≥„Éú„É´: {', '.join(available_symbols)}")
    print("ÂêÑ„Ç∑„É≥„Éú„É´„Åß„ÉÜ„Çπ„Éà„Åó„ÄÅË©≥Á¥∞„Å™„ÉÅ„É£„Éº„Éà„ÇíÁîüÊàê„Åó„Åæ„Åô„ÄÇ")
    
    # ÂêÑ„Ç∑„É≥„Éú„É´„Åß„ÉÜ„Çπ„ÉàÂÆüË°å
    results = {}
    
    for symbol in available_symbols[:3]:  # ÊúÄÂàù„ÅÆ3„Å§„ÅÆ„Ç∑„É≥„Éú„É´„Åß„ÉÜ„Çπ„Éà
        try:
            result = test_with_visualization(symbol=symbol, n_points=800)
            if result:
                results[symbol] = result
                print(f"‚úÖ {symbol} „ÉÜ„Çπ„ÉàÂÆå‰∫Ü")
            else:
                print(f"‚ùå {symbol} „ÉÜ„Çπ„ÉàÂ§±Êïó")
        except Exception as e:
            print(f"‚ùå {symbol} „ÉÜ„Çπ„Éà‰∏≠„Å´„Ç®„É©„Éº: {e}")
        
        print("-" * 60)
    
    # Á∑èÂêàÁµêÊûú
    if results:
        print(f"\n{'='*80}")
        print("üèÜ **Á∑èÂêà„ÉÜ„Çπ„ÉàÁµêÊûú**")
        print("="*80)
        
        for symbol, data in results.items():
            perf = data['performance']
            
            noise_reduction = perf['noise_reduction']['reduction_percentage']
            avg_confidence = perf['confidence_analysis']['avg_confidence']
            current_trend = perf['trend_analysis']['current_trend']
            
            print(f"\n{symbol}:")
            print(f"  ÁèæÂú®„ÅÆ„Éà„É¨„É≥„Éâ: {current_trend.upper()}")
            print(f"  „Éé„Ç§„Ç∫Èô§ÂéªÁéá: {noise_reduction:.1f}%")
            print(f"  Âπ≥Âùá‰ø°È†ºÂ∫¶: {avg_confidence:.3f}")
            print(f"  „ÉÅ„É£„Éº„Éà„Éï„Ç°„Ç§„É´: ultimate_ma_v3_{symbol.lower()}_real_data_analysis.png")
    
    print(f"\n‚úÖ UltimateMA V3 Real Data Demo with Visualization ÂÆå‰∫Ü")
    print("üåü ÂÆüÈöõ„ÅÆBinance„Éá„Éº„Çø„Åß„ÅÆÈáèÂ≠ê„Éã„É•„Éº„É©„É´ÂàÜÊûê + „ÉÅ„É£„Éº„ÉàÂèØË¶ñÂåñÂÆå‰∫ÜÔºÅ")
    print("üìä ÁîüÊàê„Åï„Çå„Åü„ÉÅ„É£„Éº„Éà„Éï„Ç°„Ç§„É´„Çí„ÅîÁ¢∫Ë™ç„Åè„Å†„Åï„ÅÑ„ÄÇ")


if __name__ == "__main__":
    main() 